syntax = "proto3";
package bringyour;

import "frame.proto";

option go_package = "bringyour.com/protocol";



// stream_id

// destination hops
// src=id, dest=id, id, id, id
// src=id+nat, dest=id, id, id
// nat, nat, nat, id

// receiving (when there is a nat dest), source builds back into the original dest array
// src=id dest=id+nat
// src=id, id dest=id+nat



// the goal of the transfer path is to allow multiple hop destinations
// while each hop cannot determine how many hops came before
// only the original sender knows there are no prior hops
message TransferPath {
    // ulid
    repeated bytes destination_ids = 1;
    // ulid
    repeated bytes source_ids = 2;

    optional bytes destination_nat_id
    optional bytes source_nat_id
    // ulid
    bytes stream_id
}

// there's a weakness with the initial transfer path model where early hops ("entry nodes") know with good confidence the sender, 
// because they know the destination path and the prob of the path length being complete
// (later hops "exit nodes" do not know the sender)
// the v2 which is supported by the protocol but not live,
// uses the platform to set up a nat_id for each hop on the route so that a message could just be sent to the next destination nat
// any node would not know how many remaining destination hops, avoiding the "entry node" weakness



message TransferFrame {
    TransferPath transfer_path;

    Frame frame = 3;

    // TODO have the option to use fully encrypt the frame bytes using pke
    // TODO for the initial use case of already encrypted frame data, this is not needed
    // optional bool encrypted = 4;
}


// this is the minimal subset of `TransferFrame` used when making a routing decision
message FilteredTransferFrame {
    // ulid
    bytes destination_id = 1;
    // ulid
    bytes source_id = 2;
}


message Pack {
    // ulid
    bytes message_id = 1;
    uint64 sequence_id = 2;
    // this marks the head message in the sender's sequence
    // it means that any message with an earlier sequence_id won't arrive
    // and is used when a receiver is recreated with zero state
    bool head = 3;

    repeated Frame frames = 4;
}


// ack of a later message means all prior messages have been ackd
message Ack {
    // ulid
    bytes message_id = 1;
}


// this is a connection local message that is sent at the start of each connection to the control platform
// there is no response. the other side will close the connection if no auth
// no auth can happen if the jwt is not valid, or the client_id is not associated with the jwt
// note that association of the client_id to the jwt uses the api (see openapi spec in the api dir)
message ControlAuth {
    bytes by_jwt = 1;
    // ulid
    bytes client_id = 2;
    // the version of the app, a semver managed by warp
    string app_version = 3;
}


enum ProvideMode {
    NETWORK = 0;
    FF = 1;
    PUBLIC = 2;
}


message Provide {
    repeated ProvideKey keys = 1;
}


message ProvideKey {
    ProvideMode mode = 1;
    // used to sign the `StoredContract` bytes
    bytes provide_secret_key = 2;
}



message CreateStream {

    // hops on the stream
    // ulid
    repeated bytes destination_ids = 1;
        
    // when evaluating the completed contracts, the send and receive count involving the source_id
    // is the baseline to evaluate the other contracts for disputes
    // ulid
    bytes source_id 

}

message CreateStreamResult {
    error
    stream_id

    // if nats were set up along the route, this is the next hop
    destination_nat_id
}



// control message to create a contract
// platform sends a CreateContractResult
message CreateContract {
    // ulid
    bytes destination_id = 1;
    uint32 transfer_byte_count = 2;

    bytes stream_id
}


enum ContractError {
    NO_PERMISSION = 0;
    INSUFFICIENT_BALANCE = 1;
}


message CreateContractResult {    
    optional ContractError error = 1;
    optional Contract contract = 2;
}


// append this message inline a pack to enable the connection
message Contract {
    // ulid
    bytes stored_contract_bytes = 1;
    // `stored_contract_bytes` signed with the `provider_secret_key`
    bytes stored_contract_hmac = 2;
    ProvideMode provide_mode = 3;
}


message StoredContract {
    bytes contract_id = 1;
    bytes source_id = 2;
    bytes destination_id = 3;
    bytes stream_id
    uint32 transfer_byte_count = 4;
}


// control message
message CloseContract {
    bytes contract_id = 1;
    uint32 acked_byte_count = 2;
    uint32 unacked_byte_count = 3;
}


// peer auditing
// the acl will block contracts between between two parties with bad audits of each other
message PeerAudit {
    // ulid
    bytes peer_id = 1;
    // number of seconds in the audit
    uint32 duration = 2;
    bool abuse = 3;
    uint32 bad_contract_count = 4;
    uint32 discarded_byte_count = 5;
    uint32 discarded_count = 6;
    uint32 bad_message_byte_count = 7;
    uint32 bad_message_count = 8;
    uint32 send_byte_count = 9;
    uint32 send_count = 10;
    uint32 resend_byte_count = 11;
    uint32 resend_count = 12;
}

