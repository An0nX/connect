syntax = "proto3";
package bringyour;

import "frame.proto";

option go_package = "bringyour.com/protocol";


// FIXME peer signer keys are not needed for the initial release since all traffic goes through the platfomr which enforces source ids



message TransferFrame {
    // ulid
    bytes destination_id = 1;
    // ulid
    bytes source_id = 2;
    // TODO have the option to use fully encrypt the frame bytes using pke, where the sender keys are shared to the receiver
    Frame frame = 4;
}


// this is the minimal subset of `TransferFrame` used when making a routing decision
message FilteredTransferFrame {
    // ulid
    bytes destination_id = 1;
    // ulid
    bytes source_id = 2;
}



message Pack {
    // ulid
    bytes message_id = 1;
    uint64 sequence_id = 2;

    repeated Frame frames = 3;
}


// ack of a later message means all prior messages have been ackd
message Ack {
    // ulid
    bytes messsage_id = 1;
}


// this is a connection local message that is sent at the start of each connection to the control platform
// there is no response. the other side should close the connection if no auth
message ControlAuth {
    bytes by_jwt = 1;
    // all control messages are signed with this
    bytes control_secret_key = 2;
    bytes client_secret_key = 3;
}

/*
message SetKey {
    // ulid
    bytes destination_id
    // this key is used by the client for all messages from client_id -> destination_id
    // (each source,dest pair have a different secret key)
    // the platform pushes the secret key to connected clients as `SourceSecretKey` before any data is sent
    // in this scheme, all three of the source, dest, and platform know the secret key for messages from source -> dest via the platform
    bytes client_secret_key = 3;
    // TODO have the option to use PKI to enable fully encrypted frames
}

message SourceKey {
    // ulid
    bytes source_id
    bytes source_secret_key = 3;
}
*/




enum ProvideMode {
    OFF = 0;
    NETWORK = 1;
    NETWORK_AND_SHARED = 2;
    ALL = 3;
}

message Provide {
    ProvideMode mode = 1;
    // the platform uses this key to sign the contract_jwts
    bytes provider_secret_key = 2;
}


// control message to create a contract
// acks with a CreateContractResult
// source_id cannot equal destination_id
message CreateContract {
    // ulid
    bytes destination_id = 2;
    uint64 transfer_byte_count = 3;
    // if set, if there is a contract newer than the last known, return the newest
    // ulid
    bytes previous_contract_id = 4;
}
// TODO acls are applied on create contract
// TODO forward from source_id to destination_id is allowed if there is at least one active contract between the two
// TODO when the network supports ip/subnet routing, add destination_ip for a contract


enum ContractError {
    NO_PERMISSION = 0;
    INSUFFICIENT_BALANCE = 1;
}

message CreateContractResult {    
    optional ContractError error = 1;
    optional Contract contract = 2;
}

// append this message inline a pack to enable the connection
message Contract {
    // ulid
    bytes stored_contract_bytes = 1;
    // `stored_contract_bytes` signed with the `provider_secret_key`
    bytes stored_contract_hmac = 2;
}

message StoredContract {
    bytes contract_id = 1;
    bytes source_id = 2;
    bytes destination_id = 3;
    uint64 transfer_byte_count = 4;
}


// control message
message CloseContract {

    bytes contract_id = 1;
    uint64 acked_byte_count = 2;
    // audit data
    uint64 unacked_byte_count = 3;
    


}

// peer auditing
// the acl will block contracts between between two parties with bad audits of each other
message PeerAudit {
    source_id
    discarded_byte_count
    bad_contract_count
    send_byte_count
    send_count
    uint64 resend_byte_count = 3;
    resend_count
}

